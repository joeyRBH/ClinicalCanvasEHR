// Global template storage (fetched from API)
let documentTemplates = {};
let templateNames = {};

// Fetch templates from API
async function loadTemplates() {
    try {
        const response = await fetch(`${API_URL}/templates`);
        if (!response.ok) throw new Error('Failed to fetch templates');
        
        const templates = await response.json();
        
        // Build documentTemplates object
        templates.forEach(template => {
            documentTemplates[template.template_id] = {
                id: template.template_id,
                name: template.name,
                fullContent: template.full_content,
                fields: template.fields // Already parsed as JSON by postgres
            };
            
            templateNames[template.template_id] = template.name;
        });
        
        console.log('âœ… Loaded', Object.keys(documentTemplates).length, 'document templates from database');
    } catch (error) {
        console.error('Error loading templates:', error);
        alert('Failed to load document templates. Please refresh the page.');
    }
}

// UPDATE the loadData function to also load templates:
async function loadData() {
    try {
        // Load templates first, then other data
        await loadTemplates();
        
        [clients, appointments, assignedDocs] = await Promise.all([
            apiCall('/clients'),
            apiCall('/appointments'),
            apiCall('/assigned-docs')
        ]);
        renderClients();
        updateDocBadge();
    } catch (error) {
        console.error('Load error:', error);
    }
}

// UPDATE the accessDocument function to load templates if not loaded:
async function accessDocument() {
    const code = document.getElementById('authCode').value.toUpperCase().trim();
    if (!code) {
        alert('Please enter an access code');
        return;
    }
    
    try {
        // Load templates if not already loaded
        if (Object.keys(documentTemplates).length === 0) {
            await loadTemplates();
        }
        
        const docs = await apiCall(`/assigned-docs?auth_code=${code}`, { skipAuth: true });
        const pendingDocs = docs.filter(d => d.status === 'pending');
        
        if (pendingDocs.length > 0) {
            currentDocuments = pendingDocs;
            currentDocIndex = 0;
            await logAudit('client_access', { code, doc_count: pendingDocs.length }, 'Client');
            showClientPortal();
        } else {
            alert('Invalid or expired code. These documents may have already been completed.');
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// UPDATE the openAssignDoc function to populate checkboxes dynamically:
function openAssignDoc() {
    const select = document.getElementById('assignClient');
    select.innerHTML = '<option value="">Select Client</option>' + 
        clients.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
    
    // Dynamically create checkboxes from loaded templates
    const checkboxContainer = document.querySelector('#assignDocModal .doc-checkbox').parentElement.parentElement;
    checkboxContainer.innerHTML = Object.keys(documentTemplates).map(templateId => {
        const template = documentTemplates[templateId];
        return `<label style="display: block; margin-bottom: 10px; cursor: pointer;">
            <input type="checkbox" value="${templateId}" class="doc-checkbox" style="margin-right: 8px;">
            ${template.name}
        </label>`;
    }).join('');
    
    document.getElementById('assignDocModal').style.display = 'block';
}

// IMPORTANT: Add this at the very end of the script, before the closing </script> tag:
// Initialize templates on page load
(async function initApp() {
    await loadTemplates();
    
    if (authToken && currentUser) {
        showApp();
    }
})();
